import Foundation

private let defaultFunction = "{{DEFAULT_FUNCTION}}"
private let defaultIterations: UInt32 = 20
private let defaultWarmup: UInt32 = 3

struct BenchParams {
    let function: String
    let iterations: UInt32
    let warmup: UInt32

    private struct EncodedBenchSpec: Decodable {
        let function: String
        let iterations: UInt32
        let warmup: UInt32
    }

    static func fromBundle() -> BenchParams? {
        guard let url = Bundle.main.url(forResource: "bench_spec", withExtension: "json") else {
            print("[BenchRunner] No bench_spec.json found in bundle, will use process info or defaults")
            return nil
        }
        do {
            let data = try Data(contentsOf: url)
            let decoded = try JSONDecoder().decode(EncodedBenchSpec.self, from: data)
            print("[BenchRunner] Loaded config from bench_spec.json: function=\(decoded.function), iterations=\(decoded.iterations), warmup=\(decoded.warmup)")
            return BenchParams(function: decoded.function, iterations: decoded.iterations, warmup: decoded.warmup)
        } catch {
            print("[BenchRunner] ERROR: Failed to parse bench_spec.json: \(error)")
            print("[BenchRunner] Will fall back to process info or defaults")
            return nil
        }
    }

    static func fromProcessInfo() -> BenchParams {
        let info = ProcessInfo.processInfo
        var function = defaultFunction
        var iterations = defaultIterations
        var warmup = defaultWarmup
        var sources: [String] = []

        // Check environment variables
        if let envFunction = info.environment["BENCH_FUNCTION"], !envFunction.isEmpty {
            function = envFunction
            sources.append("function from BENCH_FUNCTION env")
        }

        if let envIterations = info.environment["BENCH_ITERATIONS"], !envIterations.isEmpty {
            if let parsed = UInt32(envIterations) {
                iterations = parsed
                sources.append("iterations from BENCH_ITERATIONS env")
            } else {
                print("[BenchRunner] WARNING: Failed to parse BENCH_ITERATIONS='\(envIterations)' as integer, using default: \(defaultIterations)")
            }
        }

        if let envWarmup = info.environment["BENCH_WARMUP"], !envWarmup.isEmpty {
            if let parsed = UInt32(envWarmup) {
                warmup = parsed
                sources.append("warmup from BENCH_WARMUP env")
            } else {
                print("[BenchRunner] WARNING: Failed to parse BENCH_WARMUP='\(envWarmup)' as integer, using default: \(defaultWarmup)")
            }
        }

        // Check launch arguments (override environment variables)
        for arg in info.arguments {
            if arg.hasPrefix("--bench-function=") {
                if let value = arg.split(separator: "=", maxSplits: 1).last {
                    function = String(value)
                    sources.append("function from --bench-function arg")
                }
            } else if arg.hasPrefix("--bench-iterations=") {
                if let value = arg.split(separator: "=", maxSplits: 1).last {
                    if let parsed = UInt32(value) {
                        iterations = parsed
                        sources.append("iterations from --bench-iterations arg")
                    } else {
                        print("[BenchRunner] WARNING: Failed to parse --bench-iterations='\(value)' as integer, using current value: \(iterations)")
                    }
                }
            } else if arg.hasPrefix("--bench-warmup=") {
                if let value = arg.split(separator: "=", maxSplits: 1).last {
                    if let parsed = UInt32(value) {
                        warmup = parsed
                        sources.append("warmup from --bench-warmup arg")
                    } else {
                        print("[BenchRunner] WARNING: Failed to parse --bench-warmup='\(value)' as integer, using current value: \(warmup)")
                    }
                }
            }
        }

        // Log resolution source
        if sources.isEmpty {
            print("[BenchRunner] Using hardcoded defaults: function=\(function), iterations=\(iterations), warmup=\(warmup)")
        } else {
            print("[BenchRunner] Resolved params from process info: function=\(function), iterations=\(iterations), warmup=\(warmup) (sources: \(sources.joined(separator: ", ")))")
        }

        return BenchParams(function: function, iterations: iterations, warmup: warmup)
    }

    static func resolved() -> BenchParams {
        if let bundled = fromBundle() {
            return bundled
        }
        return fromProcessInfo()
    }
}

enum {{PROJECT_NAME_PASCAL}}FFI {
    static func runCurrentBenchmark() async -> String {
        let params = BenchParams.resolved()
        return run(params: params)
    }

    static func run(params: BenchParams) -> String {
        let spec = BenchSpec(
            name: params.function,
            iterations: params.iterations,
            warmup: params.warmup
        )

        do {
            let report = try runBenchmark(spec: spec)
            return formatBenchReport(report)
        } catch let error as BenchError {
            print("[BenchRunner] ERROR: Benchmark failed: \(error)")
            return formatBenchError(error)
        } catch {
            print("[BenchRunner] ERROR: Unexpected error during benchmark execution: \(error)")
            return "Unexpected error: \(error.localizedDescription)"
        }
    }

    /// Formats a duration in nanoseconds to a human-readable string.
    /// Uses milliseconds (ms) by default, switches to seconds (s) if >= 1000ms.
    private static func formatDuration(_ ns: UInt64) -> String {
        let ms = Double(ns) / 1_000_000.0
        if ms >= 1000.0 {
            let secs = ms / 1000.0
            return String(format: "%.3fs", secs)
        } else {
            return String(format: "%.3fms", ms)
        }
    }

    private static func formatBenchReport(_ report: BenchReport) -> String {
        var output = "=== Benchmark Results ===\n\n"
        output += "Function: \(report.spec.name)\n"
        output += "Iterations: \(report.spec.iterations)\n"
        output += "Warmup: \(report.spec.warmup)\n\n"

        output += "Samples (\(report.samples.count)):\n"
        for (index, sample) in report.samples.enumerated() {
            output += "  \(index + 1). \(formatDuration(sample.durationNs))\n"
        }

        if !report.samples.isEmpty {
            let durations = report.samples.map { $0.durationNs }
            let min = durations.min() ?? 0
            let max = durations.max() ?? 0
            let avg = durations.reduce(0, +) / UInt64(durations.count)

            output += "\nStatistics:\n"
            output += "  Min: \(formatDuration(min))\n"
            output += "  Max: \(formatDuration(max))\n"
            output += "  Avg: \(formatDuration(avg))\n"
        }

        return output
    }

    private static func formatBenchError(_ error: BenchError) -> String {
        // Generic error formatting - works with any BenchError variant
        // This avoids hardcoding specific error cases that may not exist in all schemas
        return "Benchmark error: \(error.localizedDescription)"
    }
}
