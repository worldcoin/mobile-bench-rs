import Foundation

private let defaultFunction = "{{DEFAULT_FUNCTION}}"
private let defaultIterations: UInt32 = 20
private let defaultWarmup: UInt32 = 3

struct BenchParams {
    let function: String
    let iterations: UInt32
    let warmup: UInt32

    private struct EncodedBenchSpec: Decodable {
        let function: String
        let iterations: UInt32
        let warmup: UInt32
    }

    static func fromBundle() -> BenchParams? {
        guard let url = Bundle.main.url(forResource: "bench_spec", withExtension: "json") else {
            print("[BenchRunner] No bench_spec.json found in bundle, will use process info or defaults")
            return nil
        }
        do {
            let data = try Data(contentsOf: url)
            let decoded = try JSONDecoder().decode(EncodedBenchSpec.self, from: data)
            print("[BenchRunner] Loaded config from bench_spec.json: function=\(decoded.function), iterations=\(decoded.iterations), warmup=\(decoded.warmup)")
            return BenchParams(function: decoded.function, iterations: decoded.iterations, warmup: decoded.warmup)
        } catch {
            print("[BenchRunner] ERROR: Failed to parse bench_spec.json: \(error)")
            print("[BenchRunner] Will fall back to process info or defaults")
            return nil
        }
    }

    static func fromProcessInfo() -> BenchParams {
        let info = ProcessInfo.processInfo
        var function = info.environment["BENCH_FUNCTION"] ?? defaultFunction
        var iterations = UInt32(info.environment["BENCH_ITERATIONS"] ?? "") ?? defaultIterations
        var warmup = UInt32(info.environment["BENCH_WARMUP"] ?? "") ?? defaultWarmup

        for arg in info.arguments {
            if arg.hasPrefix("--bench-function=") {
                function = String(arg.split(separator: "=", maxSplits: 1).last ?? Substring(function))
            } else if arg.hasPrefix("--bench-iterations=") {
                iterations = UInt32(arg.split(separator: "=", maxSplits: 1).last ?? "") ?? iterations
            } else if arg.hasPrefix("--bench-warmup=") {
                warmup = UInt32(arg.split(separator: "=", maxSplits: 1).last ?? "") ?? warmup
            }
        }

        return BenchParams(function: function, iterations: iterations, warmup: warmup)
    }

    static func resolved() -> BenchParams {
        if let bundled = fromBundle() {
            return bundled
        }
        return fromProcessInfo()
    }
}

enum {{PROJECT_NAME_PASCAL}}FFI {
    static func runCurrentBenchmark() async -> String {
        let params = BenchParams.resolved()
        return run(params: params)
    }

    static func run(params: BenchParams) -> String {
        let spec = BenchSpec(
            name: params.function,
            iterations: params.iterations,
            warmup: params.warmup
        )

        do {
            let report = try runBenchmark(spec: spec)
            return formatBenchReport(report)
        } catch let error as BenchError {
            return formatBenchError(error)
        } catch {
            return "Unexpected error: \(error.localizedDescription)"
        }
    }

    private static func formatBenchReport(_ report: BenchReport) -> String {
        var output = "=== Benchmark Results ===\n\n"
        output += "Function: \(report.spec.name)\n"
        output += "Iterations: \(report.spec.iterations)\n"
        output += "Warmup: \(report.spec.warmup)\n\n"

        output += "Samples (\(report.samples.count)):\n"
        for (index, sample) in report.samples.enumerated() {
            let durationUs = Double(sample.durationNs) / 1_000.0
            output += "  \(index + 1). \(String(format: "%.3f", durationUs)) μs (\(sample.durationNs) ns)\n"
        }

        if !report.samples.isEmpty {
            let durations = report.samples.map { Double($0.durationNs) / 1_000.0 }
            let min = durations.min() ?? 0.0
            let max = durations.max() ?? 0.0
            let avg = durations.reduce(0, +) / Double(durations.count)

            output += "\nStatistics:\n"
            output += "  Min: \(String(format: "%.3f", min)) μs\n"
            output += "  Max: \(String(format: "%.3f", max)) μs\n"
            output += "  Avg: \(String(format: "%.3f", avg)) μs\n"
        }

        return output
    }

    private static func formatBenchError(_ error: BenchError) -> String {
        // Generic error formatting - works with any BenchError variant
        // This avoids hardcoding specific error cases that may not exist in all schemas
        return "Benchmark error: \(error.localizedDescription)"
    }
}
